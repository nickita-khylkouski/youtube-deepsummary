{% extends "base.html" %}

{% block title %}{% if video_title %}{{ video_title }} - YouTube Transcript & Summary{% else %}YouTube Video {{ video_id }} - Transcript & Summary{% endif %}{% endblock %}

{% block content %}
    <!-- Include Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
    <div class="video-info" style="position: relative;">
        <!-- Delete Icon -->
        <button onclick="deleteVideo('{{ video_id }}', '{{ video_title|e }}')" style="position: absolute; top: 10px; right: 10px; background: white; color: #333; border: 1px solid #ddd; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="Delete Video">🗑️</button>
        <div style="display: flex; align-items: flex-start; gap: 20px; margin-bottom: 20px;">
            <div style="flex-shrink: 0;">
                <img src="{{ thumbnail_url }}" 
                     alt="Video thumbnail" 
                     style="width: 320px; height: 180px; object-fit: cover; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                     onerror="this.style.display='none'">
            </div>
            <div style="flex-grow: 1;">
                {% if video_title %}
                    <h2>{{ video_title }}</h2>
                    <p style="color: #666; margin: 5px 0;">
                        {% if channel_info and channel_info.handle and channel_info.handle.strip() %}
                            <strong><a href="/@{{ channel_info.handle }}" style="color: #333; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">{{ channel_info.channel_name or 'Unknown Channel' }}</a></strong>
                        {% elif channel_info and channel_info.channel_name %}
                            <strong>{{ channel_info.channel_name }}</strong>
                        {% else %}
                            <strong>Unknown Channel</strong>
                        {% endif %}
                        {% if published_at %} • {{ published_at.strftime('%B %d, %Y') if published_at.strftime else published_at[:10] }}{% endif %}
                        {% if video_duration %} • {{ "%.0f"|format(video_duration // 60) }}:{{ "%02.0f"|format(video_duration % 60) }} minutes{% endif %}
                        • <a href="https://www.youtube.com/watch?v={{ video_id }}" target="_blank" style="color: #ff0000; text-decoration: none;">YouTube</a>{% if has_blog_post %} • <a href="/{{ channel_info.handle }}/{{ url_path }}" style="color: #1976d2; text-decoration: none;">Blog</a>{% endif %}
                    </p>
                {% else %}
                    <h2>📺 Video ID: {{ video_id }}</h2>
                {% endif %}
                <p style="margin-top: 10px;">
                    {% if not has_transcript %}
                        <button id="extractTranscriptBtn" onclick="extractTranscript('{{ video_id }}')" style="background: transparent; color: #374151; border: 2px solid #e5e7eb; padding: 10px 20px; border-radius: 12px; cursor: pointer; display: inline-block; margin-right: 12px; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" onmouseover="this.style.borderColor='#9ca3af'; this.style.boxShadow='0 4px 6px rgba(0,0,0,0.1)'" onmouseout="this.style.borderColor='#e5e7eb'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'">📝 Extract Transcript</button>
                    {% endif %}
                    {% if not has_chapters %}
                        <button id="extractChaptersBtn" onclick="extractChapters('{{ video_id }}')" style="background: transparent; color: #374151; border: 2px solid #e5e7eb; padding: 10px 20px; border-radius: 12px; cursor: pointer; display: inline-block; margin-right: 12px; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" onmouseover="this.style.borderColor='#9ca3af'; this.style.boxShadow='0 4px 6px rgba(0,0,0,0.1)'" onmouseout="this.style.borderColor='#e5e7eb'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'">📚 Extract Chapters</button>
                    {% endif %}
                    {% if has_transcript and summarize_enabled and not has_summary %}
                        <button id="generateSummaryBtn" onclick="generateSummary('{{ video_id }}')" style="background: #5BA7F7; color: white; border: none; padding: 10px 20px; border-radius: 12px; cursor: pointer; display: inline-block; margin-right: 12px; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 4px 6px rgba(91, 167, 247, 0.3);" onmouseover="this.style.background='#4A90E2'; this.style.boxShadow='0 6px 12px rgba(91, 167, 247, 0.4)'" onmouseout="this.style.background='#5BA7F7'; this.style.boxShadow='0 4px 6px rgba(91, 167, 247, 0.3)'">🤖 Generate AI Summary</button>
                    {% endif %}
                </p>
            </div>
        </div>
    </div>
    
    <!-- Proxy info hidden 
    <div class="proxy-info">
        <strong>🌐 Proxy used:</strong> {{ proxy_used }}
    </div>
    -->
    

    
    <!-- Generate AI Summary button moved to video info section -->
    
    {% if chapters %}
        <div class="chapters-info">
            <h3 onclick="toggleChaptersList()" style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 8px;">
                <i data-lucide="chevron-right" id="chapters-chevron" style="width: 20px; height: 20px; transition: transform 0.2s;"></i>
                📚 Chapter Summaries ({{ chapters|length }})
            </h3>
            <ul id="chapters-list" style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0; list-style: none; display: none;">
                {% for chapter in chapters %}
                    <li style="margin-bottom: 8px; position: relative;">
                        • <strong>{{ chapter.title }}</strong> - {{ "%.0f"|format(chapter.time // 60) }}:{{ "%02.0f"|format(chapter.time % 60) }}  
                        {% if summarize_enabled %}
                            {% set chapter_summary = chapter_summaries_lookup.get(chapter.time|int) %}
                            {% if chapter_summary %}
                                <span onclick="viewChapterSummary({{ chapter.time|int }})" 
                                      data-chapter-time="{{ chapter.time|int }}"
                                      data-chapter-title="{{ chapter.title|e }}"
                                      data-summary-text="{{ chapter_summary.summary_text|e }}"
                                      data-model-used="{{ chapter_summary.model_used|e }}"
                                      data-prompt-name="{{ chapter_summary.prompt_name|e }}"
                                      style="cursor: pointer; margin-left: 8px; color: #4CAF50;" 
                                      title="View AI summary for this chapter">
                                    <i data-lucide="check-circle" style="width: 16px; height: 16px;"></i>
                                </span>
                            {% else %}
                                <span onclick="generateChapterSummary('{{ video_id }}', {{ chapter.time|int }}, '{{ chapter.title|e }}')" 
                                      style="cursor: pointer; margin-left: 8px; color: #9C27B0;" 
                                      title="Generate AI summary for this chapter"
                                      id="chapter-icon-{{ chapter.time|int }}">
                                    <i data-lucide="brain" style="width: 16px; height: 16px;"></i>
                                </span>
                            {% endif %}
                        {% endif %}
                    </li>
                {% endfor %}
            </ul>
        </div>
    {% endif %}
    
    <!-- Summary section - will be populated by JavaScript or shown if pre-loaded -->
    <div id="summary-section" style="{% if not summary and not summary_error %}display: none;{% endif %}">
        {% if summary %}
            <div class="summary-section">
                <!-- Summary Header with History Navigation - Fixed 2-row layout -->
                <div style="margin-bottom: 15px;">
                    <!-- Row 1: Title and Summary Info -->
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                        <h3 style="margin: 0;">🤖 AI-Generated Summary:</h3>
                        <div id="summary-info" style="font-size: 14px; color: #666;">
                            <!-- This will be populated with current summary info -->
                        </div>
                    </div>
                    
                    <!-- Row 2: Controls -->
                    {% if summarize_enabled %}
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button id="historyBtn" onclick="toggleSummaryHistory()" style="background: #6c757d; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; display: none;">📚 History</button>
                            <select id="promptSelect" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; background: white;">
                                <option value="">Loading prompts...</option>
                            </select>
                            <select id="modelSelect" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; background: white;">
                                <option value="">Loading models...</option>
                            </select>
                            <button id="regenerateSummaryBtn" onclick="regenerateSummaryWithModel('{{ video_id }}')" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">🔄 Regenerate</button>
                        </div>
                    {% endif %}
                </div>

                <!-- Summary History Panel (Initially Hidden) -->
                <div id="summary-history-panel" style="display: none; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0; font-size: 16px;">Summary History</h4>
                        <button onclick="toggleSummaryHistory()" style="background: none; border: none; font-size: 18px; cursor: pointer;">✕</button>
                    </div>
                    <div id="summary-history-list" style="max-height: 300px; overflow-y: auto;">
                        <!-- This will be populated with history items -->
                        <div style="text-align: center; color: #666; padding: 20px;">Loading history...</div>
                    </div>
                </div>

                <!-- Current Summary Content -->
                <div class="summary-content">
                    <div class="markdown-content" id="current-summary">{{ summary|safe }}</div>
                </div>
            </div>
            <hr style="margin: 30px 0; border: 1px solid #ddd;">
        {% endif %}
        
        {% if summary_error %}
            <div class="summary-error">
                <h3>❌ Summary Error:</h3>
                <p style="color: #d32f2f;">{{ summary_error }}</p>
            </div>
            <hr style="margin: 30px 0; border: 1px solid #ddd;">
        {% endif %}
    </div>
    
    {% if chapters %}
        <div class="chapters-info">
            <h3>📝 Transcript Chapters ({{ chapters|length }} chapters):</h3>
            <ul style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0; list-style: none;">
                {% for chapter in chapters %}
                    <li style="margin-bottom: 8px; position: relative;">
                        • <strong>{{ chapter.title }}</strong> - 
                        <a href="javascript:void(0)" onclick="scrollToChapter({{ chapter.time|int }})" style="color: #0066cc; text-decoration: underline; margin-right: 8px;" title="Go to transcript section">{{ "%.0f"|format(chapter.time // 60) }}:{{ "%02.0f"|format(chapter.time % 60) }}</a>
                        <a href="https://www.youtube.com/watch?v={{ video_id }}&t={{ chapter.time|int }}s" target="_blank" style="text-decoration: none; margin-left: 4px; margin-right: 8px;" title="Watch on YouTube">
                            <svg width="16" height="16" viewBox="0 0 24 24" style="vertical-align: middle;">
                                <path fill="#ff0000" d="M23.498 6.186a2.998 2.998 0 00-2.112-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.386.505A2.998 2.998 0 00.502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a2.998 2.998 0 002.112 2.136c1.881.505 9.386.505 9.386.505s7.505 0 9.386-.505a2.998 2.998 0 002.112-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                        </a>
                    </li>
                {% endfor %}
            </ul>
        </div>
    {% endif %}
    
    {% if has_transcript %}
        <div class="transcript-options" style="margin: 20px 0;">
            <button onclick="toggleTranscriptView()" id="toggleBtn" style="background: #5BA7F7; color: white; border: none; padding: 10px 20px; border-radius: 12px; cursor: pointer; margin-right: 12px; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 4px 6px rgba(91, 167, 247, 0.3);" onmouseover="this.style.background='#4A90E2'; this.style.boxShadow='0 6px 12px rgba(91, 167, 247, 0.4)'" onmouseout="this.style.background='#5BA7F7'; this.style.boxShadow='0 4px 6px rgba(91, 167, 247, 0.3)'">
                📖 Switch to Detailed View
            </button>
            <button onclick="copyTranscriptToClipboard()" id="copyBtn" style="background: transparent; color: #374151; border: 2px solid #e5e7eb; padding: 10px 20px; border-radius: 12px; cursor: pointer; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" onmouseover="this.style.borderColor='#9ca3af'; this.style.boxShadow='0 4px 6px rgba(0,0,0,0.1)'" onmouseout="this.style.borderColor='#e5e7eb'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)'">
                📋 Copy Transcript
            </button>
        </div>
        
        <h3>📝 Transcript ({{ transcript|length }} entries):</h3>
        
        <!-- Formatted readable transcript (default view) -->
        <div id="formatted-transcript" class="transcript-container" style="display: block;">
            <div class="formatted-text" style="background: #f9f9f9; padding: 15px; border-radius: 5px; line-height: 1.6; font-family: Georgia, serif; max-height: 600px; overflow-y: auto;">
                <div id="formatted-transcript-content" style="white-space: pre-wrap; font-family: Georgia, serif; margin: 0;">{{ formatted_transcript|safe }}</div>
            </div>
        </div>
        
        <!-- Detailed timestamp transcript (hidden by default) -->
        <div id="detailed-transcript" class="transcript-container" style="display: none;">
            {% for entry in transcript %}
                <div class="transcript-entry" data-time="{{ entry.time|int }}" id="timestamp-{{ entry.time|int }}">
                    <div class="timestamp">[{{ entry.formatted_time }}] ({{ "%.2f"|format(entry.time) }}s)</div>
                    <div class="text">{{ entry.text }}</div>
                </div>
            {% endfor %}
        </div>
    {% else %}
        <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #666; margin-bottom: 20px;">📝 No Transcript Available</h3>
            <p style="color: #888; margin-bottom: 20px;">Click the "Extract Transcript" button above to download the transcript for this video.</p>
            <div id="extraction-status" style="display: none; margin-top: 20px;">
                <p style="color: #0066cc;">⏳ Extracting transcript... Please wait.</p>
            </div>
        </div>
    {% endif %}
    
    <script>
        function toggleTranscriptView() {
            const formattedDiv = document.getElementById('formatted-transcript');
            const detailedDiv = document.getElementById('detailed-transcript');
            const toggleBtn = document.getElementById('toggleBtn');
            
            if (formattedDiv.style.display === 'none') {
                // Show formatted, hide detailed
                formattedDiv.style.display = 'block';
                detailedDiv.style.display = 'none';
                toggleBtn.textContent = '📖 Switch to Detailed View';
            } else {
                // Show detailed, hide formatted
                formattedDiv.style.display = 'none';
                detailedDiv.style.display = 'block';
                toggleBtn.textContent = '📄 Switch to Readable View';
            }
        }
        
        function getTextNodes(element) {
            const textNodes = [];
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            return textNodes;
        }
        
        function scrollToChapter(chapterTime) {
            console.log('scrollToChapter called with time:', chapterTime);
            
            // Check if transcript elements exist
            const formattedDiv = document.getElementById('formatted-transcript');
            const detailedDiv = document.getElementById('detailed-transcript');
            
            // If no transcript is available, just open YouTube at the chapter timestamp
            if (!formattedDiv && !detailedDiv) {
                window.open(`https://www.youtube.com/watch?v={{ video_id }}&t=${chapterTime}s`, '_blank');
                return;
            }
            
            if (formattedDiv && formattedDiv.style.display !== 'none') {
                // In formatted view - first try to find chapter anchor
                const chapterId = 'chapter-' + chapterTime;
                const chapterAnchor = document.getElementById(chapterId);
                console.log('Looking for chapter anchor:', chapterId, 'Found:', !!chapterAnchor);
                
                if (chapterAnchor) {
                    // Found chapter anchor - scroll to it
                    console.log('Scrolling to chapter anchor');
                    chapterAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    // Highlight the chapter section briefly
                    const originalBg = chapterAnchor.style.backgroundColor;
                    chapterAnchor.style.backgroundColor = '#fff3cd';
                    chapterAnchor.style.border = '2px solid #ffc107';
                    chapterAnchor.style.borderRadius = '4px';
                    chapterAnchor.style.padding = '4px';
                    setTimeout(() => {
                        chapterAnchor.style.backgroundColor = originalBg;
                        chapterAnchor.style.border = '';
                        chapterAnchor.style.borderRadius = '';
                        chapterAnchor.style.padding = '';
                    }, 3000);
                    return;
                }
                
                // No chapter anchor found - use transcript data to estimate position
                console.log('No chapter anchor found, estimating position...');
                const transcriptData = {{ transcript|tojson }};
                let closestEntryIndex = 0;
                let closestDiff = Infinity;
                
                // Find the closest transcript entry to the chapter time
                transcriptData.forEach((entry, index) => {
                    const diff = Math.abs(entry.time - chapterTime);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestEntryIndex = index;
                    }
                });
                
                const formattedContent = document.getElementById('formatted-transcript-content');
                const closestEntry = transcriptData[closestEntryIndex];
                console.log('Closest entry found at index:', closestEntryIndex, 'with time:', closestEntry?.time);
                
                if (closestEntry && formattedContent) {
                    // Calculate scroll position within the transcript container
                    const progressPercentage = closestEntryIndex / transcriptData.length;
                    console.log('Scrolling to estimated position:', Math.round(progressPercentage * 100) + '%');
                    
                    // Get the scrollable container (the .formatted-text div)
                    const scrollableContainer = formattedContent.parentElement;
                    const contentHeight = formattedContent.scrollHeight;
                    const containerHeight = scrollableContainer.clientHeight;
                    
                    // Calculate target scroll position within the container
                    const maxScrollTop = contentHeight - containerHeight;
                    const targetScrollTop = maxScrollTop * progressPercentage;
                    
                    console.log('Container height:', containerHeight, 'Content height:', contentHeight, 'Max scroll:', maxScrollTop, 'Target scroll:', targetScrollTop);
                    
                    // First, scroll the page to show the transcript section
                    formattedDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    // Then scroll within the transcript container
                    setTimeout(() => {
                        scrollableContainer.scrollTo({ 
                            top: Math.max(0, Math.min(targetScrollTop, maxScrollTop)), 
                            behavior: 'smooth' 
                        });
                        
                        // Highlight the scrolled area briefly
                        scrollableContainer.style.borderLeft = '4px solid #ffc107';
                        scrollableContainer.style.backgroundColor = '#fff9e6';
                        setTimeout(() => {
                            scrollableContainer.style.borderLeft = '';
                            scrollableContainer.style.backgroundColor = '';
                        }, 2000);
                    }, 300); // Wait for page scroll to start before internal scroll
                } else {
                    // Fallback: scroll to formatted transcript start
                    console.log('No transcript entry found, scrolling to transcript start');
                    formattedDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            } else if (detailedDiv) {
                // In detailed view - find the closest timestamp entry
                const timestampEntries = document.querySelectorAll('.transcript-entry[data-time]');
                let closestEntry = null;
                let closestDiff = Infinity;
                
                timestampEntries.forEach(entry => {
                    const entryTime = parseInt(entry.getAttribute('data-time'));
                    const diff = Math.abs(entryTime - chapterTime);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestEntry = entry;
                    }
                });
                
                if (closestEntry) {
                    closestEntry.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    // Highlight the entry temporarily
                    const originalBg = closestEntry.style.backgroundColor;
                    const originalBorder = closestEntry.style.borderLeft;
                    const originalPadding = closestEntry.style.paddingLeft;
                    
                    closestEntry.style.backgroundColor = '#fff3cd';
                    closestEntry.style.borderLeft = '4px solid #ffc107';
                    closestEntry.style.paddingLeft = '10px';
                    
                    setTimeout(() => {
                        closestEntry.style.backgroundColor = originalBg;
                        closestEntry.style.borderLeft = originalBorder;
                        closestEntry.style.paddingLeft = originalPadding;
                    }, 3000);
                }
            } else {
                // No transcript available, open YouTube at chapter timestamp
                window.open(`https://www.youtube.com/watch?v={{ video_id }}&t=${chapterTime}s`, '_blank');
            }
        }
        
        function convertMarkdownToHtml(markdown) {
            let html = markdown;
            
            // Convert headers (## Header -> <h2>Header</h2>)
            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
            
            // Convert **bold** to <strong>bold</strong>
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em>italic</em>
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            
            // Convert [text](url) to <a href="url" target="_blank">text</a>
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            // Convert bullet lists (- item or * item)
            html = html.replace(/^[-*] (.+)$/gm, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // Convert numbered lists (1. item)
            html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
            
            // Convert line breaks to paragraphs
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p>(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
            html = html.replace(/<p>(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)<\/p>/g, '$1');
            
            return html;
        }
        
        function generateSummary(videoId) {
            const btn = document.getElementById('generateSummaryBtn');
            const summarySection = document.getElementById('summary-section');
            
            // Get formatted transcript text (readable version, not detailed timestamps)
            const formattedTranscript = {{ formatted_transcript|tojson }};
            
            // Update button to show loading state
            btn.textContent = '⏳ Generating...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Make AJAX request to generate summary with formatted transcript
            fetch('/api/summary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: videoId,
                    formatted_transcript: formattedTranscript,
                    force_regenerate: false
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Convert markdown to HTML
                        const summaryHtml = convertMarkdownToHtml(data.summary);
                        
                        // Show summary section
                        summarySection.style.display = 'block';
                        summarySection.innerHTML = `
                            <div class="summary-section">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h3 style="margin: 0;">🤖 AI-Generated Summary:</h3>
                                    <button id="regenerateSummaryBtn" onclick="regenerateSummary('${videoId}')" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">🔄 Regenerate</button>
                                </div>
                                <div class="summary-content">
                                    <div class="markdown-content">${summaryHtml}</div>
                                </div>
                            </div>
                            <hr style="margin: 30px 0; border: 1px solid #ddd;">
                        `;
                        
                        // Add H2 snippet icons to the new summary
                        setTimeout(addH2SnippetIcons, 100);
                        
                        // Update the button text to indicate it can regenerate
                        btn.textContent = '🤖 Regenerate AI Summary';
                        btn.disabled = false;
                        btn.style.background = '#2196f3';
                    } else {
                        // Show error
                        summarySection.style.display = 'block';
                        summarySection.innerHTML = `
                            <div class="summary-error">
                                <h3>❌ Summary Error:</h3>
                                <p style="color: #d32f2f;">${data.error}</p>
                            </div>
                            <hr style="margin: 30px 0; border: 1px solid #ddd;">
                        `;
                        
                        // Reset button
                        btn.textContent = '🤖 Generate AI Summary';
                        btn.disabled = false;
                        btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    }
                })
                .catch(error => {
                    // Show error
                    summarySection.style.display = 'block';
                    summarySection.innerHTML = `
                        <div class="summary-error">
                            <h3>❌ Summary Error:</h3>
                            <p style="color: #d32f2f;">Failed to generate summary: ${error.message}</p>
                        </div>
                        <hr style="margin: 30px 0; border: 1px solid #ddd;">
                    `;
                    
                    // Reset button
                    btn.textContent = '🤖 Generate AI Summary';
                    btn.disabled = false;
                    btn.style.background = '#2196f3';
                });
        }
        
        function generateChapterSummary(videoId, chapterTime, chapterTitle) {
            // Find the icon span that was clicked
            const iconSpan = document.getElementById(`chapter-icon-${chapterTime}`);
            
            if (!iconSpan) return;
            
            // Update icon to show loading state
            const originalIcon = iconSpan.innerHTML;
            iconSpan.innerHTML = '<i data-lucide="loader-2" style="width: 16px; height: 16px; animation: spin 1s linear infinite;"></i>';
            iconSpan.style.color = '#666';
            iconSpan.style.cursor = 'default';
            iconSpan.onclick = null; // Disable clicking during loading
            
            // Initialize the new loading icon
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Get the chapter transcript segment
            fetch(`/api/chapter-summary`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: videoId,
                    chapter_time: chapterTime,
                    chapter_title: chapterTitle
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show chapter summary in a modal or section
                        showChapterSummaryModal(chapterTitle, data.summary, data.model_used, data.prompt_name);
                        
                        // Update icon to success state
                        iconSpan.innerHTML = '<i data-lucide="check-circle" style="width: 16px; height: 16px;"></i>';
                        iconSpan.style.color = '#4CAF50';
                        iconSpan.style.cursor = 'pointer';
                        iconSpan.title = 'View AI summary for this chapter';
                        
                        // Update span data attributes with the new summary, model, and prompt
                        iconSpan.setAttribute('data-summary-text', data.summary);
                        iconSpan.setAttribute('data-model-used', data.model_used);
                        iconSpan.setAttribute('data-prompt-name', data.prompt_name || 'Unknown Prompt');
                        iconSpan.setAttribute('data-chapter-time', chapterTime);
                        iconSpan.setAttribute('data-chapter-title', chapterTitle);
                        
                        // Change the onclick to show the existing summary
                        iconSpan.onclick = () => viewChapterSummary(chapterTime);
                        
                        // Initialize the new success icon
                        if (typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }
                    } else {
                        // Show error
                        alert('Error generating chapter summary: ' + data.error);
                        
                        // Reset icon
                        iconSpan.innerHTML = originalIcon;
                        iconSpan.style.color = '#9C27B0';
                        iconSpan.style.cursor = 'pointer';
                        iconSpan.onclick = () => generateChapterSummary(videoId, chapterTime, chapterTitle);
                        
                        // Re-initialize the original icon
                        if (typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }
                    }
                })
                .catch(error => {
                    // Show error
                    alert('Failed to generate chapter summary: ' + error.message);
                    
                    // Reset icon
                    iconSpan.innerHTML = originalIcon;
                    iconSpan.style.color = '#9C27B0';
                    iconSpan.style.cursor = 'pointer';
                    iconSpan.onclick = () => generateChapterSummary(videoId, chapterTime, chapterTitle);
                    
                    // Re-initialize the original icon
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                });
        }
        
        // Global variables for chapter summary regeneration
        let currentChapterTitle = null;
        let currentChapterTime = null;
        let currentVideoId = '{{ video_id }}';
        
        function showChapterSummaryModal(chapterTitle, summary, modelUsed = null, promptName = null) {
            console.log('showChapterSummaryModal called with:', { chapterTitle, summary, summaryType: typeof summary, modelUsed, promptName });
            
            // Reset version control state for new chapter
            chapterVersionHistory = [];
            currentChapterSummaryId = null;
            
            // Store current chapter info for regeneration
            currentChapterTitle = chapterTitle;
            // Extract chapter time and prompt name from the clicked element (we'll need this)
            const chapterElements = document.querySelectorAll('[data-chapter-title]');
            for (let elem of chapterElements) {
                if (elem.getAttribute('data-chapter-title') === chapterTitle) {
                    currentChapterTime = elem.getAttribute('data-chapter-time');
                    // Get prompt name from data attribute if not provided
                    if (!promptName) {
                        promptName = elem.getAttribute('data-prompt-name');
                    }
                    break;
                }
            }
            
            console.log('Chapter info extracted:', {
                title: currentChapterTitle,
                time: currentChapterTime,
                prompt: promptName,
                model: modelUsed
            });
            
            // Remove any existing modal
            const existingModal = document.getElementById('chapterSummaryModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Handle the summary text - it might be JSON-encoded from the template
            let summaryText = summary;
            if (typeof summary === 'string' && summary.startsWith('"') && summary.endsWith('"')) {
                try {
                    summaryText = JSON.parse(summary);
                    console.log('Successfully parsed JSON summary:', summaryText.substring(0, 100) + '...');
                } catch (e) {
                    console.error('Failed to parse JSON summary:', e);
                    // If JSON parsing fails, use as-is
                    summaryText = summary;
                }
            } else {
                console.log('Summary is not JSON-encoded, using as-is');
            }
            
            // Format the summary if it's raw markdown
            const formattedSummary = summaryText.includes('<') ? summaryText : convertMarkdownToHtml(summaryText);
            console.log('Formatted summary preview:', formattedSummary.substring(0, 100) + '...');
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'chapterSummaryModal';
            modal.style.cssText = `
                position: fixed;
                z-index: 1001;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; width: 90%; max-width: 800px; max-height: 80vh; overflow-y: auto; position: relative;">
                    <div style="padding: 20px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 10px;">
                        <div style="flex: 1; min-width: 250px;">
                            <h3 style="margin: 0; color: #9C27B0;">AI-Generated Summary</h3>
                            <h4 style="margin: 5px 0 0 0; color: #666;">${chapterTitle}</h4>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <!-- Version Navigation Buttons (hidden by default, shown only for chapters with multiple versions) -->
                            <div id="chapterVersionNav" style="display: none; gap: 8px; align-items: center;">
                                <button id="prevChapterVersionBtn" onclick="navigateChapterVersion('prev')" style="background: #f8f9fa; border: 1px solid #ddd; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; outline: none; -webkit-tap-highlight-color: transparent;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                    ← Previous
                                </button>
                                <button id="nextChapterVersionBtn" onclick="navigateChapterVersion('next')" style="background: #f8f9fa; border: 1px solid #ddd; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; outline: none; -webkit-tap-highlight-color: transparent;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                    Next →
                                </button>
                            </div>
                            <button onclick="closeChapterSummaryModal()" style="background: none; border: none; cursor: pointer; color: #666; padding: 4px; border-radius: 4px; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; outline: none; -webkit-tap-highlight-color: transparent;" onmouseover="this.style.background='#f0f0f0'; this.style.color='#333'" onmouseout="this.style.background='none'; this.style.color='#666'">
                                ✕
                            </button>
                        </div>
                    </div>
                    <div style="padding: 20px;">
                        
                        <!-- Regenerate Controls under main heading -->
                        <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 20px;">
                            <select id="chapterPromptSelect" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; background: white; min-width: 100px;">
                                <option value="">Loading prompts...</option>
                            </select>
                            <select id="chapterModelSelect" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; background: white; min-width: 100px;">
                                <option value="">Loading models...</option>
                            </select>
                            <button id="regenerateChapterBtn" onclick="regenerateChapterSummary()" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s ease; outline: none; -webkit-tap-highlight-color: transparent;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">
                                Regenerate
                            </button>
                        </div>
                        
                        <div class="markdown-content chapter-summary-content" id="chapterSummaryContent">${formattedSummary}</div>
                        
                        <!-- Model and Prompt info moved below summary content -->
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; font-size: 13px; color: #666;">
                            <span id="chapterVersionInfo" style="background: #f0f0f0; padding: 3px 8px; border-radius: 12px; font-size: 12px;">
                                Loading version info...
                            </span>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Initialize Lucide icons for the modal
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeChapterSummaryModal();
                }
            };
            
            // Load model and prompt options for chapter summary regeneration
            setTimeout(() => {
                loadChapterRegenerateOptions();
                addH2SnippetIcons();
                loadChapterVersionHistory();
            }, 100);
        }
        
        function closeChapterSummaryModal() {
            const modal = document.getElementById('chapterSummaryModal');
            if (modal) {
                modal.remove();
            }
        }

        // Chapter Version Management Functions
        let chapterVersionHistory = [];
        let currentChapterSummaryId = null;

        function loadChapterVersionHistory() {
            if (!currentChapterTitle || !currentChapterTime) {
                console.log('Missing chapter info for version history', {
                    title: currentChapterTitle,
                    time: currentChapterTime
                });
                // Hide navigation buttons if no chapter info
                const navDiv = document.getElementById('chapterVersionNav');
                if (navDiv) {
                    navDiv.style.display = 'none';
                }
                return;
            }

            console.log('=== LOADING VERSION HISTORY FOR NEW CHAPTER ===');
            console.log('Chapter:', {
                videoId: currentVideoId,
                chapterTime: currentChapterTime,
                chapterTitle: currentChapterTitle
            });

            // Reset version state to ensure clean slate for this chapter
            chapterVersionHistory = [];
            currentChapterSummaryId = null;
            
            // Hide navigation buttons while loading
            const navDiv = document.getElementById('chapterVersionNav');
            if (navDiv) {
                navDiv.style.display = 'none';
            }

            fetch(`/api/chapter-summary/history/${currentVideoId}/${currentChapterTime}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Version history API response:', data);
                    
                    if (data.success && data.history && data.history.length > 0) {
                        chapterVersionHistory = data.history;
                        
                        console.log('Version history loaded for this chapter:', {
                            chapterTitle: currentChapterTitle,
                            chapterTime: currentChapterTime,
                            totalVersions: chapterVersionHistory.length,
                            versions: chapterVersionHistory.map(v => ({
                                version: v.version_number,
                                isCurrent: v.is_current,
                                id: v.chapter_summary_id,
                                title: v.chapter_title
                            }))
                        });
                        
                        updateChapterVersionDisplay();
                        
                        // Show navigation buttons ONLY if this specific chapter has multiple versions
                        if (navDiv) {
                            if (chapterVersionHistory.length > 1) {
                                navDiv.style.display = 'flex';
                                console.log(`✅ Showing navigation buttons - ${chapterVersionHistory.length} versions found for "${currentChapterTitle}"`);
                            } else {
                                navDiv.style.display = 'none';
                                console.log(`❌ Hiding navigation buttons - only ${chapterVersionHistory.length} version for "${currentChapterTitle}"`);
                            }
                        }
                        
                        // Set current chapter summary ID
                        const currentVersion = chapterVersionHistory.find(v => v.is_current);
                        if (currentVersion) {
                            currentChapterSummaryId = currentVersion.chapter_summary_id;
                        }
                    } else {
                        console.log(`No version history found for chapter "${currentChapterTitle}"`);
                        chapterVersionHistory = [];
                        if (navDiv) {
                            navDiv.style.display = 'none';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading chapter version history:', error);
                    chapterVersionHistory = [];
                    if (navDiv) {
                        navDiv.style.display = 'none';
                    }
                });
        }

        function updateChapterVersionDisplay() {
            const currentVersion = chapterVersionHistory.find(v => v.is_current);
            const versionInfo = document.getElementById('chapterVersionInfo');
            
            if (currentVersion && versionInfo) {
                const promptName = currentVersion.prompt_name || 'None';
                const modelUsed = currentVersion.model_used || 'Unknown Model';
                versionInfo.textContent = `v${currentVersion.version_number} | ${currentVersion.chapter_title} | ${modelUsed}`;
                
                console.log('Updated version display:', {
                    version: currentVersion.version_number,
                    title: currentVersion.chapter_title,
                    model: currentVersion.model_used
                });
            } else if (versionInfo && chapterVersionHistory.length === 0) {
                // Fallback for when no version history is loaded yet
                // Use the original modal parameters if available
                const modalTitle = document.querySelector('#chapterSummaryModal h4');
                const titleText = modalTitle ? modalTitle.textContent : 'Chapter';
                versionInfo.textContent = `v1 | ${titleText} | Loading...`;
            }
        }

        function navigateChapterVersion(direction) {
            if (chapterVersionHistory.length === 0) return;
            
            const currentIndex = chapterVersionHistory.findIndex(v => v.is_current);
            if (currentIndex === -1) return;
            
            let newIndex;
            if (direction === 'prev') {
                // Go to previous version (older version - higher index since newest first)
                newIndex = currentIndex + 1;
                if (newIndex >= chapterVersionHistory.length) newIndex = 0; // Wrap to first
            } else if (direction === 'next') {
                // Go to next version (newer version - lower index since newest first)  
                newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = chapterVersionHistory.length - 1; // Wrap to last
            } else {
                return;
            }
            
            const targetVersion = chapterVersionHistory[newIndex];
            if (targetVersion && targetVersion.chapter_summary_id !== currentChapterSummaryId) {
                switchToChapterVersion(targetVersion.chapter_summary_id);
            }
        }

        function switchToChapterVersion(chapterSummaryId) {
            const version = chapterVersionHistory.find(v => v.chapter_summary_id === chapterSummaryId);
            if (!version) return;
            
            // Set as current chapter summary via API
            fetch('/api/chapter-summary/set-current', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: currentVideoId,
                    chapter_time: currentChapterTime,
                    chapter_summary_id: chapterSummaryId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the modal content with new summary
                    const contentDiv = document.getElementById('chapterSummaryContent');
                    if (contentDiv) {
                        contentDiv.innerHTML = data.summary;
                    }
                    
                    // Update version history
                    chapterVersionHistory.forEach(v => v.is_current = v.chapter_summary_id === chapterSummaryId);
                    updateChapterVersionDisplay();
                    
                    // Update current chapter summary ID
                    currentChapterSummaryId = chapterSummaryId;
                    
                    // Re-add snippet icons
                    setTimeout(addH2SnippetIcons, 100);
                } else {
                    alert('Error switching chapter version: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error switching chapter version:', error);
                alert('Error switching chapter version');
            });
        }
        
        function loadChapterRegenerateOptions() {
            // Load prompts for chapter regeneration
            fetch('/settings/prompts')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.prompts) {
                        const promptSelect = document.getElementById('chapterPromptSelect');
                        if (promptSelect) {
                            promptSelect.innerHTML = '<option value="">Select prompt...</option>';
                            
                            data.prompts.forEach(prompt => {
                                const option = document.createElement('option');
                                option.value = prompt.id;
                                option.textContent = prompt.name;
                                promptSelect.appendChild(option);
                            });
                            
                            // Set default to the first prompt if available
                            if (data.prompts.length > 0) {
                                promptSelect.value = data.prompts[0].id;
                            }
                        }
                    } else {
                        const promptSelect = document.getElementById('chapterPromptSelect');
                        if (promptSelect) {
                            promptSelect.innerHTML = '<option value="">No prompts available</option>';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading prompts:', error);
                    const promptSelect = document.getElementById('chapterPromptSelect');
                    if (promptSelect) {
                        promptSelect.innerHTML = '<option value="">Error loading prompts</option>';
                    }
                });
            
            // Load models and get current configured model for chapter regeneration
            Promise.all([
                fetch('/api/models'),
                fetch('/settings/summarizer-settings')
            ]).then(async ([modelsResponse, settingsResponse]) => {
                const modelsData = await modelsResponse.json();
                const settingsData = await settingsResponse.json();
                
                if (modelsData.success && modelsData.models) {
                    const modelSelect = document.getElementById('chapterModelSelect');
                    if (modelSelect) {
                        modelSelect.innerHTML = '<option value="">Select model...</option>';
                        
                        // Get configured model from settings
                        let configuredModel = null;
                        if (settingsData.status === 'success' && settingsData.settings) {
                            configuredModel = settingsData.settings.model;
                        }
                        
                        // Group models by provider
                        for (const [provider, models] of Object.entries(modelsData.models)) {
                            const optgroup = document.createElement('optgroup');
                            // Capitalize provider name for display
                            optgroup.label = provider.charAt(0).toUpperCase() + provider.slice(1);
                            
                            models.forEach(modelId => {
                                const option = document.createElement('option');
                                option.value = modelId;
                                
                                // Create user-friendly display name
                                let displayName = modelId;
                                if (modelId === 'gpt-4.1') {
                                    displayName = 'GPT-4.1';
                                } else if (modelId === 'gpt-4.1-mini') {
                                    displayName = 'GPT-4.1 Mini';
                                } else if (modelId === 'gpt-3.5-turbo') {
                                    displayName = 'GPT-3.5 Turbo';
                                } else if (modelId === 'claude-sonnet-4-20250514') {
                                    displayName = 'Claude Sonnet 4';
                                } else if (modelId === 'claude-3-5-sonnet-20241022') {
                                    displayName = 'Claude 3.5 Sonnet';
                                }
                                
                                option.textContent = displayName;
                                optgroup.appendChild(option);
                            });
                            
                            modelSelect.appendChild(optgroup);
                        }
                        
                        // Set default to the configured model if available, otherwise first model
                        const allModels = Object.values(modelsData.models).flat();
                        if (configuredModel && allModels.includes(configuredModel)) {
                            modelSelect.value = configuredModel;
                        } else if (allModels.length > 0) {
                            modelSelect.value = allModels[0];
                        }
                    }
                } else {
                    const modelSelect = document.getElementById('chapterModelSelect');
                    if (modelSelect) {
                        modelSelect.innerHTML = '<option value="">No models available</option>';
                    }
                }
            }).catch(error => {
                console.error('Error loading models or settings:', error);
                const modelSelect = document.getElementById('chapterModelSelect');
                if (modelSelect) {
                    modelSelect.innerHTML = '<option value="">Error loading models</option>';
                }
            });
        }
        
        function regenerateChapterSummary() {
            const btn = document.getElementById('regenerateChapterBtn');
            const promptSelect = document.getElementById('chapterPromptSelect');
            const modelSelect = document.getElementById('chapterModelSelect');
            const summaryContent = document.getElementById('chapterSummaryContent');
            const modelUsedSpan = document.getElementById('chapterModelUsed');
            const promptUsedSpan = document.getElementById('chapterPromptUsed');
            
            if (!currentChapterTitle || !currentChapterTime || !currentVideoId) {
                alert('Missing chapter information for regeneration');
                return;
            }
            
            const selectedPrompt = promptSelect.value;
            const selectedModel = modelSelect.value;
            
            if (!selectedPrompt) {
                alert('Please select a prompt');
                return;
            }
            
            if (!selectedModel) {
                alert('Please select a model');
                return;
            }
            
            // Get the selected prompt name for display
            const selectedPromptName = promptSelect.options[promptSelect.selectedIndex].textContent;
            
            // Update button to show loading state
            btn.textContent = '⏳ Regenerating...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Make request to regenerate chapter summary
            fetch('/api/chapter-summary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: currentVideoId,
                    chapter_time: parseFloat(currentChapterTime),
                    chapter_title: currentChapterTitle,
                    force_regenerate: true,
                    model: selectedModel,
                    prompt_id: selectedPrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the summary content
                    summaryContent.innerHTML = data.summary;
                    
                    // Update the model used info
                    if (modelUsedSpan) {
                        modelUsedSpan.textContent = data.model_used || selectedModel;
                    }
                    
                    // Update the prompt used info
                    if (promptUsedSpan) {
                        promptUsedSpan.textContent = data.prompt_name || selectedPromptName;
                    }
                    
                    // Add snippet functionality to the updated content
                    setTimeout(() => {
                        addH2SnippetIcons();
                    }, 100);
                    
                    // Reload version history to show new version and navigation buttons
                    setTimeout(() => {
                        loadChapterVersionHistory();
                    }, 200);
                    
                    // Reset button state
                    btn.textContent = 'Regenerate';
                    btn.disabled = false;
                    btn.style.background = '#5BA7F7';
                } else {
                    alert('Error regenerating chapter summary: ' + data.error);
                    
                    // Reset button state
                    btn.textContent = '🔄 Regenerate';
                    btn.disabled = false;
                    btn.style.background = '#5BA7F7';
                }
            })
            .catch(error => {
                console.error('Error regenerating chapter summary:', error);
                alert('Failed to regenerate chapter summary: ' + error.message);
                
                // Reset button state
                btn.textContent = '🔄 Regenerate';
                btn.disabled = false;
                btn.style.background = '#5BA7F7';
            });
        }
        
        // Debug function to log chapter summaries data (disabled to prevent display issues)
        function debugChapterSummaries() {
            try {
                console.log('=== DEBUG: Chapter Summaries ===');
                // Don't log the full chapter data to prevent display issues
                console.log('Chapter summaries available: true');
                
                // Check if buttons exist
                const viewButtons = document.querySelectorAll('button[data-chapter-time]');
                console.log('Found', viewButtons.length, 'View Summary buttons');
                
            } catch (error) {
                console.error('Error in debugChapterSummaries:', error);
            }
        }
        
        // Call debug function when page loads (disabled to prevent display issues)
        // document.addEventListener('DOMContentLoaded', function() {
        //     console.log('DOM loaded, running debug...');
        //     debugChapterSummaries();
        // });
        
        // Also run debug after a short delay to ensure everything is loaded (disabled)
        // setTimeout(function() {
        //     console.log('Delayed debug check...');
        //     debugChapterSummaries();
        // }, 1000);
        
        // Function to view chapter summary using data attributes
        function viewChapterSummary(chapterTime) {
            console.log('viewChapterSummary called with chapterTime:', chapterTime);
            
            // Find the span that was clicked (check both buttons and spans for compatibility)
            const element = document.querySelector(`span[data-chapter-time="${chapterTime}"], button[data-chapter-time="${chapterTime}"]`);
            if (!element) {
                console.error('Element not found for chapter time:', chapterTime);
                return;
            }
            
            // Get data from element attributes
            const chapterTitle = element.getAttribute('data-chapter-title');
            const summaryText = element.getAttribute('data-summary-text');
            const modelUsed = element.getAttribute('data-model-used');
            const promptName = element.getAttribute('data-prompt-name');
            
            console.log('Found element data:', { chapterTitle, summaryTextPreview: summaryText ? summaryText.substring(0, 50) + '...' : 'No text', modelUsed, promptName });
            
            // Call the modal function with model and prompt info
            showChapterSummaryModal(chapterTitle, summaryText, modelUsed, promptName);
        }
        

        
        function regenerateSummary(videoId) {
            const btn = document.getElementById('regenerateSummaryBtn');
            const summarySection = document.getElementById('summary-section');
            
            // Get formatted transcript text (readable version, not detailed timestamps)
            const formattedTranscript = {{ formatted_transcript|tojson|safe }};
            
            // Update button to show loading state
            btn.textContent = '⏳ Regenerating...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Make AJAX request to generate summary with formatted transcript
            fetch('/api/summary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: videoId,
                    formatted_transcript: formattedTranscript,
                    force_regenerate: true
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Convert markdown to HTML
                        const summaryHtml = convertMarkdownToHtml(data.summary);
                        
                        // Update summary section with new content
                        summarySection.innerHTML = `
                            <div class="summary-section">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h3 style="margin: 0;">🤖 AI-Generated Summary:</h3>
                                    <button id="regenerateSummaryBtn" onclick="regenerateSummary('${videoId}')" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">🔄 Regenerate</button>
                                </div>
                                <div class="summary-content">
                                    <div class="markdown-content">${summaryHtml}</div>
                                </div>
                            </div>
                            <hr style="margin: 30px 0; border: 1px solid #ddd;">
                        `;
                        
                        // Add H2 snippet icons to the regenerated summary
                        setTimeout(addH2SnippetIcons, 100);
                        
                        // Update the main generate button
                        const mainBtn = document.getElementById('generateSummaryBtn');
                        if (mainBtn) {
                            mainBtn.textContent = '🤖 Regenerate AI Summary';
                            mainBtn.disabled = false;
                            mainBtn.style.background = '#2196f3';
                        }
                    } else {
                        // Show error but keep the regenerate button
                        summarySection.innerHTML = `
                            <div class="summary-error">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h3 style="margin: 0;">❌ Summary Error:</h3>
                                    <button id="regenerateSummaryBtn" onclick="regenerateSummary('${videoId}')" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">🔄 Regenerate</button>
                                </div>
                                <p style="color: #d32f2f;">${data.error}</p>
                            </div>
                            <hr style="margin: 30px 0; border: 1px solid #ddd;">
                        `;
                    }
                })
                .catch(error => {
                    // Show error but keep the regenerate button
                    summarySection.innerHTML = `
                        <div class="summary-error">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="margin: 0;">❌ Summary Error:</h3>
                                <button id="regenerateSummaryBtn" onclick="regenerateSummary('${videoId}')" style="background: #5BA7F7; color: white; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;" onmouseover="this.style.background='#4A90E2'" onmouseout="this.style.background='#5BA7F7'">🔄 Regenerate</button>
                            </div>
                            <p style="color: #d32f2f;">Failed to generate summary: ${error.message}</p>
                        </div>
                        <hr style="margin: 30px 0; border: 1px solid #ddd;">
                                            `;
                });
        }
        
        // Load available prompts for regeneration
        function loadAvailablePrompts(selectedPromptId = null) {
            fetch('/settings/prompts')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.prompts) {
                        const promptSelect = document.getElementById('promptSelect');
                        if (promptSelect) {
                            // Clear loading option
                            promptSelect.innerHTML = '';
                            
                            // Add prompts
                            data.prompts.forEach(prompt => {
                                const option = document.createElement('option');
                                option.value = prompt.id;
                                option.textContent = prompt.name;
                                
                                // Select previously selected prompt, or default if none specified
                                if (selectedPromptId && prompt.id == selectedPromptId) {
                                    option.selected = true;
                                } else if (!selectedPromptId && prompt.is_default) {
                                    option.selected = true;
                                }
                                
                                promptSelect.appendChild(option);
                            });
                            
                            // Update to current version after loading prompts (if history is loaded)
                            if (summaryHistory.length > 0) {
                                setTimeout(() => updateSelectorsToCurrentVersion(), 100);
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading prompts:', error);
                    const promptSelect = document.getElementById('promptSelect');
                    if (promptSelect) {
                        promptSelect.innerHTML = '<option value="">Error loading prompts</option>';
                    }
                });
        }

        // Load available models for regeneration
        function loadAvailableModels(selectedModelName = null) {
            fetch('/api/models')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.models) {
                        const modelSelect = document.getElementById('modelSelect');
                        if (modelSelect) {
                            // Clear loading option
                            modelSelect.innerHTML = '';
                            
                            let modelSelected = false;
                            
                            // Add providers and models
                            for (const [provider, models] of Object.entries(data.models)) {
                                const optgroup = document.createElement('optgroup');
                                optgroup.label = provider.charAt(0).toUpperCase() + provider.slice(1);
                                
                                models.forEach(model => {
                                    const option = document.createElement('option');
                                    option.value = model;
                                    option.textContent = model;
                                    
                                    // Select previously selected model, or default to Claude Sonnet 4
                                    if (selectedModelName && model === selectedModelName) {
                                        option.selected = true;
                                        modelSelected = true;
                                    } else if (!selectedModelName && model === 'claude-sonnet-4-20250514') {
                                        option.selected = true;
                                        modelSelected = true;
                                    }
                                    
                                    optgroup.appendChild(option);
                                });
                                
                                modelSelect.appendChild(optgroup);
                            }
                            
                            // If no model was selected and no specific model requested, select first available
                            if (!modelSelected && modelSelect.options.length > 0) {
                                modelSelect.selectedIndex = 0;
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading models:', error);
                    const modelSelect = document.getElementById('modelSelect');
                    if (modelSelect) {
                        modelSelect.innerHTML = '<option value="">Error loading models</option>';
                    }
                });
        }
        
        // Regenerate summary with selected model and prompt
        function regenerateSummaryWithModel(videoId) {
            const btn = document.getElementById('regenerateSummaryBtn');
            const modelSelect = document.getElementById('modelSelect');
            const promptSelect = document.getElementById('promptSelect');
            const summarySection = document.getElementById('summary-section');
            
            const selectedModel = modelSelect.value;
            const selectedPrompt = promptSelect.value;
            if (!selectedModel) {
                alert('Please select a model first');
                return;
            }
            if (!selectedPrompt) {
                alert('Please select a prompt first');
                return;
            }
            
            // Update button to show loading state
            btn.textContent = '⏳ Regenerating...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Make AJAX request to regenerate summary with selected model and prompt
            fetch('/api/summary/regenerate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: videoId,
                    model: selectedModel,
                    prompt_id: selectedPrompt
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update the current summary display
                        document.getElementById('current-summary').innerHTML = data.summary;
                        
                        // Reload summary history to show the new version
                        loadSummaryHistory(videoId);
                        
                        // Add H2 snippet icons to the regenerated summary
                        setTimeout(addH2SnippetIcons, 100);
                        
                        // Reset the regenerate button state
                        btn.textContent = '🔄 Regenerate';
                        btn.disabled = false;
                        btn.style.background = '#5BA7F7';
                        
                        // Update the main generate button
                        const mainBtn = document.getElementById('generateSummaryBtn');
                        if (mainBtn) {
                            mainBtn.textContent = '🤖 Regenerate AI Summary';
                            mainBtn.disabled = false;
                            mainBtn.style.background = '#2196f3';
                        }
                        
                        // After regeneration, ensure selectors match the new summary
                        setTimeout(() => {
                            updateSelectorsToCurrentVersion();
                        }, 1000);
                    } else {
                        // Show error and restore controls
                        alert('Error regenerating summary: ' + data.error);
                        btn.textContent = '🔄 Regenerate';
                        btn.disabled = false;
                        btn.style.background = '#5BA7F7';
                    }
                })
                .catch(error => {
                    console.error('Error regenerating summary:', error);
                    alert('Failed to regenerate summary: ' + error.message);
                    btn.textContent = '🔄 Regenerate';
                    btn.disabled = false;
                    btn.style.background = '#5BA7F7';
                });
        }
        
        function copyTranscriptToClipboard() {
            const formattedDiv = document.getElementById('formatted-transcript');
            const detailedDiv = document.getElementById('detailed-transcript');
            const copyBtn = document.getElementById('copyBtn');
            
            let textToCopy = '';
            
            // Check which view is currently visible
            const formattedVisible = formattedDiv.style.display !== 'none';
            
            if (formattedVisible) {
                // Copy formatted transcript (readable view)
                const formattedContent = document.getElementById('formatted-transcript-content');
                textToCopy = formattedContent.textContent || formattedContent.innerText;
            } else {
                // Copy detailed transcript (timestamped view)
                const transcriptEntries = document.querySelectorAll('#detailed-transcript .transcript-entry');
                const transcriptLines = [];
                
                transcriptEntries.forEach(entry => {
                    const timestamp = entry.querySelector('.timestamp').textContent;
                    const text = entry.querySelector('.text').textContent;
                    transcriptLines.push(`${timestamp} ${text}`);
                });
                
                textToCopy = transcriptLines.join('\n');
            }
            
            // Fallback function for older browsers or HTTP connections
            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.top = '-999px';
                textArea.style.left = '-999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                    document.body.removeChild(textArea);
                    return false;
                }
            }
            
            // Function to show success feedback
            function showSuccessFeedback() {
                const originalText = copyBtn.textContent;
                const originalBg = copyBtn.style.background;
                copyBtn.textContent = '✅ Copied!';
                copyBtn.style.background = '#28a745';
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = originalBg;
                }, 2000);
            }
            
            // Function to show error feedback
            function showErrorFeedback(errorMsg) {
                console.error('Copy failed:', errorMsg);
                const originalText = copyBtn.textContent;
                const originalBg = copyBtn.style.background;
                copyBtn.textContent = '❌ Copy failed';
                copyBtn.style.background = '#dc3545';
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = originalBg;
                }, 2000);
            }
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showSuccessFeedback();
                }).catch(err => {
                    // If modern API fails, try fallback
                    console.log('Modern clipboard API failed, trying fallback...');
                    if (fallbackCopyTextToClipboard(textToCopy)) {
                        showSuccessFeedback();
                    } else {
                        showErrorFeedback('Both clipboard methods failed');
                    }
                });
            } else {
                // Use fallback method directly
                if (fallbackCopyTextToClipboard(textToCopy)) {
                    showSuccessFeedback();
                } else {
                    showErrorFeedback('Clipboard not supported in this browser');
                }
            }
        }
        
        // Snippets functionality
        let saveSnippetModal = null;
        let selectedText = '';
        let contextBefore = '';
        let contextAfter = '';
        let buttonClickInProgress = false;
        let selectionTimeout = null;
        let buttonCreateTime = 0;
        let lastSaveTime = 0;
        let currentSelectionRange = null;
        
        function initializeSnippets() {
            // Listen for text selection in summary content
            document.addEventListener('mouseup', handleTextSelection);
            document.addEventListener('keyup', handleTextSelection);
            
            // Add scroll event listener to update snippet button position
            window.addEventListener('scroll', updateSnippetButtonPosition);
            window.addEventListener('resize', updateSnippetButtonPosition);
            
            // Hide button when clicking outside (with delay to avoid interfering with selection)
            document.addEventListener('click', function(e) {
                const button = document.getElementById('saveSnippetBtn');
                if (button && !button.contains(e.target) && !buttonClickInProgress) {
                    setTimeout(() => {
                        const currentButton = document.getElementById('saveSnippetBtn');
                        if (currentButton && !buttonClickInProgress) {
                            hideSaveSnippetButton();
                        }
                    }, 200);
                }
            });
            
            // Create the save snippet modal
            createSaveSnippetModal();
        }
        
        function handleTextSelection() {
            // Clear any existing timeout
            if (selectionTimeout) {
                clearTimeout(selectionTimeout);
            }
            
            // Add a small delay to prevent rapid button creation/removal
            selectionTimeout = setTimeout(() => {
                const selection = window.getSelection();
                
                if (selection.toString().trim().length > 0) {
                    // Check if selection is within a summary content area or transcript content
                    const summaryContent = selection.anchorNode.parentElement.closest('.summary-content');
                    const transcriptContent = selection.anchorNode.parentElement.closest('.transcript-container');
                    
                    if (summaryContent || transcriptContent) {
                        selectedText = selection.toString().trim();
                        
                        // If selection is from summary content, also capture HTML formatting
                        if (summaryContent) {
                            const range = selection.getRangeAt(0);
                            const clonedContents = range.cloneContents();
                            const div = document.createElement('div');
                            div.appendChild(clonedContents);
                            selectedText = div.innerHTML || selectedText; // Use HTML if available, fallback to plain text
                        }
                        
                        // Get context before and after the selection
                        const range = selection.getRangeAt(0);
                        const container = summaryContent || transcriptContent;
                        getTextContext(range, container);
                        
                        // Show save snippet button
                        showSaveSnippetButton(selection);
                    }
                } else {
                    // Don't hide button if click is in progress
                    if (!buttonClickInProgress) {
                        hideSaveSnippetButton();
                    }
                }
            }, 300); // 300ms delay to allow selection to complete
        }
        
        function getTextContext(range, container) {
            const containerText = container.textContent;
            const selectionStart = containerText.indexOf(selectedText);
            
            if (selectionStart !== -1) {
                const beforeStart = Math.max(0, selectionStart - 100);
                const afterEnd = Math.min(containerText.length, selectionStart + selectedText.length + 100);
                
                contextBefore = containerText.substring(beforeStart, selectionStart).trim();
                contextAfter = containerText.substring(selectionStart + selectedText.length, afterEnd).trim();
            }
        }
        
        function showSaveSnippetButton(selection) {
            // Remove any existing button first
            const existingButton = document.getElementById('saveSnippetBtn');
            if (existingButton) {
                existingButton.remove();
            }
            
            // Don't show button if no text is selected
            if (!selection.toString().trim()) {
                return;
            }
            
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            // Store the current selection range for position updates
            currentSelectionRange = range.cloneRange();
            
            const button = document.createElement('button');
            button.id = 'saveSnippetBtn';
            button.innerHTML = '💾 Save as Snippet';
            
            // Use absolute positioning for both summaries and transcripts
            button.style.cssText = `
                position: absolute;
                top: ${rect.bottom + window.scrollY + 5}px;
                left: ${rect.left + window.scrollX}px;
                background: #4CAF50;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                cursor: pointer;
                z-index: 9999;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                white-space: nowrap;
                transition: all 0.1s ease;
            `;
            
            // Add event listener
            button.addEventListener('click', function(e) {
                buttonClickInProgress = true;
                e.preventDefault();
                e.stopPropagation();
                
                saveSnippetDirect();
                
                hideSaveSnippetButton();
                window.getSelection().removeAllRanges();
                setTimeout(() => { buttonClickInProgress = false; }, 100);
            });
            
            document.body.appendChild(button);
            buttonCreateTime = Date.now();
            
            // Button will be hidden when user clicks outside or scrolls away
        }
        
        function hideSaveSnippetButton() {
            const existingButton = document.getElementById('saveSnippetBtn');
            if (existingButton) {
                existingButton.remove();
            }
            currentSelectionRange = null;
        }
        
        function createSaveSnippetModal() {
            const modal = document.createElement('div');
            modal.id = 'saveSnippetModal';
            modal.style.cssText = `
                display: none;
                position: fixed;
                z-index: 1001;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
            `;
            
            modal.innerHTML = `
                <div style="background: white; margin: 5% auto; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px;">
                    <h3 style="margin-top: 0;">💾 Save Snippet</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Selected Text:</label>
                        <div id="selectedTextPreview" style="background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 100px; overflow-y: auto; font-style: italic;"></div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Tags (optional):</label>
                        <input type="text" id="snippetTags" placeholder="Enter tags separated by commas" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">e.g., important, strategy, action-item</small>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeSaveSnippetModal()" style="background: #ccc; color: #333; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Cancel</button>
                        <button onclick="saveSnippet()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Save Snippet</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            saveSnippetModal = modal;
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeSaveSnippetModal();
                }
            };
        }
        
        function openSaveSnippetModal() {
            if (!saveSnippetModal) {
                createSaveSnippetModal();
            }
            
            // Show formatted text in preview if it contains HTML, otherwise show as text
            const previewElement = document.getElementById('selectedTextPreview');
            if (selectedText.includes('<') && selectedText.includes('>')) {
                previewElement.innerHTML = selectedText;
            } else {
                previewElement.textContent = selectedText;
            }
            
            document.getElementById('snippetTags').value = '';
            saveSnippetModal.style.display = 'block';
        }
        
        function closeSaveSnippetModal() {
            if (saveSnippetModal) {
                saveSnippetModal.style.display = 'none';
            }
        }
        
        function saveSnippet() {
            const tags = document.getElementById('snippetTags').value
                .split(',')
                .map(tag => tag.trim())
                .filter(tag => tag.length > 0);
            
            const data = {
                video_id: '{{ video_id }}',
                snippet_text: selectedText, // selectedText now contains HTML formatting when from summary
                context_before: contextBefore,
                context_after: contextAfter,
                tags: tags
            };
            
            fetch('/api/snippets', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeSaveSnippetModal();
                    // Show a brief success indicator
                    const successMsg = document.createElement('div');
                    successMsg.textContent = '✓ Snippet saved';
                    successMsg.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #4CAF50;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 10000;
                        font-size: 14px;
                    `;
                    document.body.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 3000);
                }
            })
            .catch(error => {
                // Silent error handling
            });
        }
        
        function saveSnippetDirect() {
            // Prevent duplicate saves within 2 seconds
            const now = Date.now();
            if (now - lastSaveTime < 2000) {
                return;
            }
            lastSaveTime = now;
            
            const data = {
                video_id: '{{ video_id }}',
                snippet_text: selectedText, // selectedText now contains HTML formatting when from summary
                context_before: contextBefore,
                context_after: contextAfter,
                tags: [] // No tags when saving directly
            };
            
            fetch('/api/snippets', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show a brief success indicator
                    const successMsg = document.createElement('div');
                    successMsg.textContent = '✓ Snippet saved';
                    successMsg.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #4CAF50;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 10000;
                        font-size: 14px;
                    `;
                    document.body.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 3000);
                }
            })
            .catch(error => {
                // Silent error handling
            });
        }
        
        
        // H2 Section Snippet Functionality
        function addH2SnippetIcons() {
            // Find all H2 elements in markdown content
            const h2Elements = document.querySelectorAll('.markdown-content h2');
            
            h2Elements.forEach((h2, index) => {
                // Skip if icon already exists
                if (h2.querySelector('.h2-snippet-icon')) {
                    return;
                }
                
                // Create snippet icon
                const icon = document.createElement('span');
                icon.className = 'h2-snippet-icon';
                icon.innerHTML = '💾';
                icon.title = 'Save this section as snippet';
                icon.setAttribute('data-h2-index', index);
                
                // Add click handler
                icon.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    saveH2Section(h2, index);
                });
                
                // Append icon to H2
                h2.appendChild(icon);
            });
        }

        function saveH2Section(h2Element, sectionIndex) {
            // Get the H2 section content (everything until the next H2 or end of content)
            const sectionContent = getH2SectionContent(h2Element);
            
            if (!sectionContent.trim()) {
                // Show error message
                const errorMsg = document.createElement('div');
                errorMsg.textContent = '⚠️ No content found in this section';
                errorMsg.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ff4444;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 10000;
                    font-size: 14px;
                `;
                document.body.appendChild(errorMsg);
                setTimeout(() => errorMsg.remove(), 3000);
                return;
            }
            
            // Prevent duplicate saves within 2 seconds
            const now = Date.now();
            if (now - lastSaveTime < 2000) {
                return;
            }
            lastSaveTime = now;
            
            // Get section title for context
            const sectionTitle = h2Element.textContent.replace('💾', '').trim();
            
            const data = {
                video_id: '{{ video_id }}',
                snippet_text: sectionContent,
                context_before: '',
                context_after: '',
                tags: []
            };
            
            // Show loading state
            const originalIcon = h2Element.querySelector('.h2-snippet-icon');
            const originalContent = originalIcon.innerHTML;
            originalIcon.innerHTML = '⏳';
            originalIcon.style.background = '#666';
            
            fetch('/api/snippets', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show success indicator
                    const successMsg = document.createElement('div');
                    successMsg.textContent = `✓ Section "${sectionTitle}" saved as snippet`;
                    successMsg.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #4CAF50;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 10000;
                        font-size: 14px;
                        max-width: 300px;
                    `;
                    document.body.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 3000);
                    
                    // Animate icon to show success
                    originalIcon.innerHTML = '✓';
                    originalIcon.style.background = '#4CAF50';
                    originalIcon.style.color = 'white';
                    setTimeout(() => {
                        originalIcon.innerHTML = originalContent;
                        originalIcon.style.background = '';
                        originalIcon.style.color = '';
                    }, 2000);
                } else {
                    throw new Error(data.message || 'Failed to save snippet');
                }
            })
            .catch(error => {
                // Show error message
                const errorMsg = document.createElement('div');
                errorMsg.textContent = `❌ Failed to save section: ${error.message}`;
                errorMsg.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ff4444;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 10000;
                    font-size: 14px;
                `;
                document.body.appendChild(errorMsg);
                setTimeout(() => errorMsg.remove(), 3000);
                
                // Reset icon
                originalIcon.innerHTML = originalContent;
                originalIcon.style.background = '';
                originalIcon.style.color = '';
            });
        }

        function getH2SectionContent(h2Element) {
            let content = '';
            let currentElement = h2Element.nextElementSibling;
            
            // Include the H2 title itself, but remove the snippet icon
            const h2Clone = h2Element.cloneNode(true);
            const iconElement = h2Clone.querySelector('.h2-snippet-icon');
            if (iconElement) {
                iconElement.remove();
            }
            content += h2Clone.outerHTML;
            
            // Traverse siblings until we hit another H2 or end of content
            while (currentElement) {
                // Stop if we encounter another H2
                if (currentElement.tagName === 'H2') {
                    break;
                }
                
                // Add the element's HTML content
                content += currentElement.outerHTML;
                currentElement = currentElement.nextElementSibling;
            }
            
            return content;
        }
        
        // Update snippet button position on scroll
        function updateSnippetButtonPosition() {
            const button = document.getElementById('saveSnippetBtn');
            if (button && currentSelectionRange) {
                try {
                    const rect = currentSelectionRange.getBoundingClientRect();
                    
                    // Check if the selection is still visible
                    if (rect.width > 0 && rect.height > 0) {
                        button.style.top = `${rect.bottom + window.scrollY + 5}px`;
                        button.style.left = `${rect.left + window.scrollX}px`;
                        button.style.position = 'absolute';
                    } else {
                        // Selection is no longer visible, hide the button
                        hideSaveSnippetButton();
                    }
                } catch (error) {
                    // Selection range is no longer valid, hide the button
                    hideSaveSnippetButton();
                }
            }
        }
        
        // Summary History Management Functions
        let summaryHistory = [];
        let currentSummaryId = null;
        let keyboardNavigationEnabled = false;
        
        function toggleSummaryHistory() {
            const panel = document.getElementById('summary-history-panel');
            const btn = document.getElementById('historyBtn');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                btn.textContent = '📚 Hide History';
                loadSummaryHistory('{{ video_id }}');
            } else {
                panel.style.display = 'none';
                btn.textContent = '📚 History';
            }
        }
        
        function loadSummaryHistory(videoId) {
            const historyList = document.getElementById('summary-history-list');
            historyList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading history...</div>';
            
            fetch(`/api/summary/history/${videoId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.history) {
                        summaryHistory = data.history;
                        renderSummaryHistory();
                        updateSummaryInfo();
                        
                        // Enable keyboard navigation if we have multiple summaries
                        keyboardNavigationEnabled = summaryHistory.length > 1;
                        
                        // Show/hide History button based on number of versions
                        const historyBtn = document.getElementById('historyBtn');
                        if (historyBtn) {
                            historyBtn.style.display = summaryHistory.length > 1 ? 'inline-block' : 'none';
                        }
                        
                        // Update current summary ID for keyboard navigation
                        const currentSummary = summaryHistory.find(e => e.is_current);
                        if (currentSummary) {
                            currentSummaryId = currentSummary.summary_id;
                        }
                        
                        // Update selectors to match current version after a delay to ensure dropdowns are loaded
                        setTimeout(() => {
                            updateSelectorsToCurrentVersion();
                        }, 500);
                    } else {
                        historyList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No history found</div>';
                        keyboardNavigationEnabled = false;
                        
                        // Hide History button when no history found
                        const historyBtn = document.getElementById('historyBtn');
                        if (historyBtn) {
                            historyBtn.style.display = 'none';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading summary history:', error);
                    historyList.innerHTML = '<div style="text-align: center; color: #d32f2f; padding: 20px;">Error loading history</div>';
                    keyboardNavigationEnabled = false;
                    
                    // Hide History button on error
                    const historyBtn = document.getElementById('historyBtn');
                    if (historyBtn) {
                        historyBtn.style.display = 'none';
                    }
                });
        }
        
        function renderSummaryHistory() {
            const historyList = document.getElementById('summary-history-list');
            
            if (summaryHistory.length === 0) {
                historyList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No summary history</div>';
                return;
            }
            
            const historyHtml = summaryHistory.map(entry => {
                const isCurrentClass = entry.is_current ? 'background: #e3f2fd; border-left: 4px solid #2196f3;' : 'background: white;';
                const currentBadge = entry.is_current ? '<span style="background: #2196f3; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-left: 8px;">CURRENT</span>' : '';
                
                return `
                    <div style="${isCurrentClass} border: 1px solid #ddd; border-radius: 6px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;" 
                         onclick="switchToSummary(${entry.summary_id})" 
                         onmouseover="this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'" 
                         onmouseout="this.style.boxShadow='none'">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center;">
                                <strong style="font-size: 14px;">Version ${entry.version_number}</strong>
                                ${currentBadge}
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                ${!entry.is_current ? `<button onclick="event.stopPropagation(); deleteSummary(${entry.summary_id})" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">🗑️ Delete</button>` : ''}
                            </div>
                        </div>
                        <div style="font-size: 13px; color: #666; margin-bottom: 4px;">
                            <strong>Model:</strong> ${entry.model_used} | 
                            <strong>Prompt:</strong> ${entry.prompt_name} | 
                            <strong>Created:</strong> ${new Date(entry.created_at).toLocaleString()}
                        </div>
                        <div style="font-size: 12px; color: #888; max-height: 40px; overflow: hidden; text-overflow: ellipsis;">
                            ${entry.summary_text.replace(/<[^>]*>/g, '').substring(0, 150)}...
                        </div>
                    </div>
                `;
            }).join('');
            
            historyList.innerHTML = historyHtml;
        }
        
        function switchToSummary(summaryId, keepHistoryOpen = false) {
            const entry = summaryHistory.find(e => e.summary_id === summaryId);
            if (!entry) return;
            
            // Set as current summary via API
            fetch('/api/summary/set-current', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: '{{ video_id }}',
                    summary_id: summaryId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the current summary display
                    document.getElementById('current-summary').innerHTML = data.summary;
                    
                    // Update history display
                    summaryHistory.forEach(e => e.is_current = e.summary_id === summaryId);
                    renderSummaryHistory();
                    updateSummaryInfo();
                    
                    // Update current summary ID for keyboard navigation
                    currentSummaryId = summaryId;
                    
                    // Update prompt and model selectors to match current version
                    setTimeout(() => {
                        updateSelectorsToCurrentVersion();
                    }, 100);
                    
                    // Add snippet icons to the new summary
                    setTimeout(addH2SnippetIcons, 100);
                    
                    // Close history panel only if not keeping it open (e.g., for keyboard navigation)
                    if (!keepHistoryOpen) {
                        toggleSummaryHistory();
                    }
                } else {
                    alert('Error switching summary: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error switching summary:', error);
                alert('Error switching summary');
            });
        }
        
        function deleteSummary(summaryId) {
            if (!confirm('Are you sure you want to delete this summary version? This action cannot be undone.')) {
                return;
            }
            
            fetch(`/api/summary/delete/${summaryId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove from history and re-render
                    summaryHistory = summaryHistory.filter(e => e.summary_id !== summaryId);
                    renderSummaryHistory();
                    updateSummaryInfo();
                } else {
                    alert('Error deleting summary: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error deleting summary:', error);
                alert('Error deleting summary');
            });
        }
        
        function updateSummaryInfo() {
            const summaryInfoDiv = document.getElementById('summary-info');
            const currentSummary = summaryHistory.find(e => e.is_current);
            
            if (currentSummary) {
                const promptName = currentSummary.prompt_name || 'Default';
                let infoHtml = `
                    <span style="background: #f0f0f0; padding: 3px 8px; border-radius: 12px; font-size: 12px;">
                        v${currentSummary.version_number} | ${promptName} | ${currentSummary.model_used}
                    </span>
                `;
                
                // Only show keyboard navigation hint if there are multiple versions
                if (summaryHistory.length > 1) {
                    infoHtml += `<span style="font-size: 11px; color: #999; margin-left: 8px;">← → to navigate</span>`;
                }
                
                summaryInfoDiv.innerHTML = infoHtml;
            }
        }

        function updateSelectorsToCurrentVersion() {
            const currentSummary = summaryHistory.find(e => e.is_current);
            if (!currentSummary) return;
            
            // Update model selector
            const modelSelect = document.getElementById('modelSelect');
            if (modelSelect && currentSummary.model_used) {
                for (let i = 0; i < modelSelect.options.length; i++) {
                    if (modelSelect.options[i].value === currentSummary.model_used) {
                        modelSelect.selectedIndex = i;
                        modelSelect.value = currentSummary.model_used;
                        break;
                    }
                }
            }
            
            // Update prompt selector
            const promptSelect = document.getElementById('promptSelect');
            if (promptSelect) {
                // For null prompt_id (legacy summaries), find the default prompt
                if (!currentSummary.prompt_id) {
                    for (let i = 0; i < promptSelect.options.length; i++) {
                        const optionText = promptSelect.options[i].textContent.trim();
                        if (optionText === 'Default Summary' || optionText === 'Default') {
                            promptSelect.selectedIndex = i;
                            promptSelect.value = promptSelect.options[i].value;
                            break;
                        }
                    }
                } else {
                    // Match by prompt_id
                    for (let i = 0; i < promptSelect.options.length; i++) {
                        if (promptSelect.options[i].value == currentSummary.prompt_id) {
                            promptSelect.selectedIndex = i;
                            promptSelect.value = currentSummary.prompt_id;
                            break;
                        }
                    }
                }
            }
        }

        // Keyboard navigation for summary history
        function navigateSummaryHistory(direction) {
            if (!keyboardNavigationEnabled || summaryHistory.length === 0) return;
            
            const currentIndex = summaryHistory.findIndex(e => e.is_current);
            if (currentIndex === -1) return;
            
            let newIndex;
            if (direction === 'left') {
                // Go to previous version (higher version number)
                newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = summaryHistory.length - 1; // Wrap to last
            } else if (direction === 'right') {
                // Go to next version (lower version number)
                newIndex = currentIndex + 1;
                if (newIndex >= summaryHistory.length) newIndex = 0; // Wrap to first
            } else {
                return;
            }
            
            const targetSummary = summaryHistory[newIndex];
            if (targetSummary && targetSummary.summary_id !== currentSummaryId) {
                switchToSummary(targetSummary.summary_id, true); // Keep history open during keyboard navigation
            }
        }

        // Keyboard event handler
        function handleKeyboardNavigation(event) {
            // Only handle arrow keys when summary section is visible and has focus context
            if (!keyboardNavigationEnabled) return;
            
            // Ignore if user is typing in an input field
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }
            
            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                navigateSummaryHistory('left');
                showNavigationFeedback('Previous version');
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                navigateSummaryHistory('right');
                showNavigationFeedback('Next version');
            }
        }

        // Show brief visual feedback for keyboard navigation
        function showNavigationFeedback(message) {
            const summarySection = document.getElementById('summary-section');
            if (!summarySection) return;
            
            // Remove existing feedback
            const existingFeedback = document.getElementById('nav-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.id = 'nav-feedback';
            feedback.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 14px;
                z-index: 1000;
                animation: fadeInOut 1.5s ease-in-out;
            `;
            feedback.textContent = message;
            
            // Add CSS animation
            if (!document.getElementById('nav-feedback-styles')) {
                const style = document.createElement('style');
                style.id = 'nav-feedback-styles';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateY(-10px); }
                        20% { opacity: 1; transform: translateY(0); }
                        80% { opacity: 1; transform: translateY(0); }
                        100% { opacity: 0; transform: translateY(-10px); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(feedback);
            
            // Auto-remove after animation
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.parentNode.removeChild(feedback);
                }
            }, 1500);
        }

        // Collapse/expand chapters list functionality
        function toggleChaptersList() {
            const chaptersList = document.getElementById('chapters-list');
            const chevron = document.getElementById('chapters-chevron');
            
            if (chaptersList.style.display === 'none') {
                chaptersList.style.display = 'block';
                chevron.innerHTML = '<i data-lucide="chevron-down" style="width: 20px; height: 20px; transition: transform 0.2s;"></i>';
            } else {
                chaptersList.style.display = 'none';
                chevron.innerHTML = '<i data-lucide="chevron-right" style="width: 20px; height: 20px; transition: transform 0.2s;"></i>';
            }
            
            // Re-initialize Lucide icons after changing the chevron
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Initialize snippets functionality when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeSnippets();
            addH2SnippetIcons();
            loadAvailablePrompts(); // Load available AI prompts for summary regeneration
            loadAvailableModels(); // Load available AI models for summary regeneration
            
            // Add keyboard navigation event listener
            document.addEventListener('keydown', handleKeyboardNavigation);
            
            // Load summary history if summary exists
            {% if summary %}
            loadSummaryHistory('{{ video_id }}');
            {% endif %}
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        });
        
        // Extract chapters functionality
        function extractChapters(videoId) {
            const btn = document.getElementById('extractChaptersBtn');
            
            // Update button to show loading state
            btn.textContent = '⏳ Extracting...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Make AJAX request to extract chapters
            fetch(`/api/chapters/${videoId}?extract_chapters=true`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success message briefly then reload page
                        btn.textContent = '✅ Success!';
                        btn.style.background = '#FF9800';
                        
                        // Reload the page after a short delay to show the extracted chapters
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        // Show error
                        btn.textContent = '❌ Failed';
                        btn.style.background = '#d32f2f';
                        
                        // Reset button after 3 seconds
                        setTimeout(() => {
                            btn.textContent = '📚 Extract Chapters';
                            btn.disabled = false;
                            btn.style.background = 'transparent';
                            btn.style.border = '2px solid #e5e7eb';
                        }, 3000);
                    }
                })
                .catch(error => {
                    // Show error
                    btn.textContent = '❌ Failed';
                    btn.style.background = '#d32f2f';
                    
                    // Reset button after 3 seconds
                    setTimeout(() => {
                        btn.textContent = '📚 Extract Chapters';
                        btn.disabled = false;
                        btn.style.background = '#FF9800';
                    }, 3000);
                });
        }
        
        // Extract transcript functionality
        function extractTranscript(videoId) {
            const btn = document.getElementById('extractTranscriptBtn');
            const statusDiv = document.getElementById('extraction-status');
            
            // Update button to show loading state
            btn.textContent = '⏳ Extracting...';
            btn.disabled = true;
            btn.style.background = '#666';
            
            // Show extraction status
            if (statusDiv) {
                statusDiv.style.display = 'block';
            }
            
            // Make AJAX request to extract transcript
            fetch(`/api/transcript/${videoId}?extract_transcript=true`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success message briefly then reload page
                        btn.textContent = '✅ Success!';
                        btn.style.background = '#4CAF50';
                        
                        // Reload the page after a short delay to show the extracted transcript
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        // Show error
                        btn.textContent = '❌ Failed';
                        btn.style.background = '#d32f2f';
                        
                        if (statusDiv) {
                            statusDiv.innerHTML = `<p style="color: #d32f2f;">❌ Failed to extract transcript: ${data.error}</p>`;
                        }
                        
                        // Reset button after 3 seconds
                        setTimeout(() => {
                            btn.textContent = '📝 Extract Transcript';
                            btn.disabled = false;
                            btn.style.background = 'transparent';
                            btn.style.border = '2px solid #e5e7eb';
                            if (statusDiv) {
                                statusDiv.style.display = 'none';
                            }
                        }, 3000);
                    }
                })
                .catch(error => {
                    // Show error
                    btn.textContent = '❌ Failed';
                    btn.style.background = '#d32f2f';
                    
                    if (statusDiv) {
                        statusDiv.innerHTML = `<p style="color: #d32f2f;">❌ Network error: ${error.message}</p>`;
                    }
                    
                    // Reset button after 3 seconds
                    setTimeout(() => {
                        btn.textContent = '📝 Extract Transcript';
                        btn.disabled = false;
                        btn.style.background = '#4CAF50';
                        if (statusDiv) {
                            statusDiv.style.display = 'none';
                        }
                    }, 3000);
                });
        }
        
        // Delete video functionality
        function deleteVideo(videoId, videoTitle) {
            // Show confirmation dialog
            const confirmed = confirm(
                `⚠️ WARNING: Are you sure you want to delete this video?\n\n` +
                `Video: "${videoTitle}"\n\n` +
                `This will permanently delete:\n` +
                `• Video data\n` +
                `• Transcript\n` +
                `• AI summary\n` +
                `• All memory snippets\n` +
                `• Video chapters\n\n` +
                `This action CANNOT be undone!\n\n` +
                `Are you sure you want to proceed?`
            );
            
            if (!confirmed) {
                return;
            }
            
            const button = event.target;
            const originalText = button.innerHTML;
            
            // Disable button and show loading state
            button.disabled = true;
            button.innerHTML = '⏳ Deleting...';
            button.style.background = '#9e9e9e';
            
            fetch(`/api/delete/${videoId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show success message
                    alert('✅ Video deleted successfully!');
                    
                    // Redirect to videos page after successful deletion
                    window.location.href = '/videos';
                } else {
                    // Show error message
                    alert('❌ Error deleting video: ' + data.message);
                    
                    // Reset button state
                    button.disabled = false;
                    button.innerHTML = originalText;
                    button.style.background = '#d32f2f';
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                alert('❌ Failed to delete video: ' + error.message);
                
                // Reset button state
                button.disabled = false;
                button.innerHTML = originalText;
                button.style.background = '#d32f2f';
            });
        }
    </script>
    
{% endblock %}